import { embeddingsService, KnowledgeContent } from './embeddings';
import { db } from './database';
import type { KnowledgeChunk } from '@/types';

export interface KnowledgeSearchResult {
  content: string;
  similarity: number;
  metadata: Record<string, any>;
  source: string;
}

export interface BusinessKnowledgeBase {
  businessType: 'medical' | 'electrician' | 'beauty' | 'general';
  businessName: string;
  hours: string;
  services: string[];
  location: string;
  phone: string;
  faqs: Array<{ question: string; answer: string }>;
  policies: string[];
}

export class KnowledgeService {
  
  /**
   * Ingest text content into the knowledge base
   */
  async ingestTextContent(
    tenantId: string,
    content: string,
    sourceType: 'faq' | 'website' | 'manual' = 'faq',
    metadata: Record<string, any> = {}
  ): Promise<KnowledgeChunk[]> {
    console.log(`Ingesting ${sourceType} content for tenant ${tenantId}: ${content.length} characters`);

    try {
      // Create knowledge source record
      const sourceId = await db.createKnowledgeSource(tenantId, 'text', content);
      await db.updateKnowledgeSourceStatus(sourceId, 'processing');

      // Process content into chunks
      const knowledgeContents = embeddingsService.processKnowledgeContent(content, sourceType);
      console.log(`Split content into ${knowledgeContents.length} chunks`);

      // Convert to database format
      const chunks: Array<Omit<KnowledgeChunk, 'id' | 'createdAt'>> = knowledgeContents.map(kc => ({
        tenantId,
        content: kc.text,
        embedding: undefined, // Will be generated by addKnowledgeChunk
        tokenCount: 0, // Will be calculated by addKnowledgeChunk
        metadata: {
          ...metadata,
          ...kc.metadata,
          sourceType,
          ingestionDate: new Date().toISOString()
        }
      }));

      // Add chunks to database (with automatic embedding generation)
      const savedChunks = await db.addKnowledgeChunks(chunks, sourceId);
      
      await db.updateKnowledgeSourceStatus(sourceId, 'completed');
      console.log(`Successfully ingested ${savedChunks.length} knowledge chunks`);

      return savedChunks;

    } catch (error) {
      console.error('Failed to ingest content:', error);
      throw error;
    }
  }

  /**
   * Search for relevant knowledge based on user query
   */
  async searchKnowledge(
    tenantId: string,
    query: string,
    limit = 3,
    similarityThreshold = 0.7
  ): Promise<KnowledgeSearchResult[]> {
    console.log(`Searching knowledge for: "${query}"`);

    try {
      const results = await db.searchKnowledge(tenantId, query, limit, similarityThreshold);
      
      return results.map(chunk => ({
        content: chunk.content,
        similarity: chunk.similarity || 0,
        metadata: chunk.metadata as Record<string, any>,
        source: (chunk.metadata as any)?.sourceType || 'unknown'
      }));

    } catch (error) {
      console.error('Knowledge search failed:', error);
      return [];
    }
  }

  /**
   * Get contextual knowledge for conversation enhancement
   */
  async getContextualKnowledge(
    tenantId: string,
    intent: string,
    userInput: string,
    conversationContext: any = {}
  ): Promise<string | null> {
    console.log(`Getting contextual knowledge for intent: ${intent}`);

    // Build search query based on intent and context
    let searchQuery = userInput;

    // Enhance search query based on intent
    if (intent === 'hours') {
      searchQuery = `hours open opening time schedule ${userInput}`;
    } else if (intent === 'services') {
      searchQuery = `services offerings what do you offer ${userInput}`;
    } else if (intent === 'booking') {
      searchQuery = `booking appointment schedule availability ${userInput}`;
    } else if (intent === 'pricing') {
      searchQuery = `price cost pricing fees charges ${userInput}`;
    }

    const results = await this.searchKnowledge(tenantId, searchQuery, 3, 0.3);
    
    if (results.length === 0) {
      console.log('No relevant knowledge found');
      return null;
    }

    // Format the most relevant knowledge for conversation use
    const topResult = results[0];
    if (topResult) {
      console.log(`Found relevant knowledge (similarity: ${topResult.similarity.toFixed(2)}): ${topResult.content.substring(0, 100)}...`);
      return topResult.content;
    }
    
    return null;
  }

  /**
   * Setup default knowledge base for different business types
   */
  async setupBusinessKnowledgeBase(
    tenantId: string,
    businessData: BusinessKnowledgeBase
  ): Promise<void> {
    console.log(`Setting up knowledge base for ${businessData.businessType}: ${businessData.businessName}`);

    // Clear existing knowledge (comment out to add multiple business types)
    // await db.clearTenantKnowledge(tenantId);

    // Prepare business information content
    const businessInfo = this.formatBusinessInfo(businessData);
    
    // Prepare FAQ content
    const faqContent = this.formatFAQContent(businessData.faqs);
    
    // Prepare services content
    const servicesContent = this.formatServicesContent(businessData.services);

    // Ingest all content
    await Promise.all([
      this.ingestTextContent(tenantId, businessInfo, 'manual', { 
        category: 'business_info',
        businessType: businessData.businessType 
      }),
      this.ingestTextContent(tenantId, faqContent, 'faq', { 
        category: 'faqs',
        businessType: businessData.businessType 
      }),
      this.ingestTextContent(tenantId, servicesContent, 'manual', { 
        category: 'services',
        businessType: businessData.businessType 
      })
    ]);

    console.log(`Knowledge base setup complete for ${businessData.businessName}`);
  }

  /**
   * Format business information for ingestion
   */
  private formatBusinessInfo(business: BusinessKnowledgeBase): string {
    return `
Business Information for ${business.businessName}

Business Type: ${business.businessType}
Location: ${business.location}
Phone: ${business.phone}

Operating Hours: ${business.hours}

About Us:
We are ${business.businessName}, a ${business.businessType} business located in ${business.location}. 
We provide professional services and can be reached at ${business.phone}.

Contact Information:
- Phone: ${business.phone}
- Location: ${business.location}
- Hours: ${business.hours}
`.trim();
  }

  /**
   * Format FAQ content for ingestion
   */
  private formatFAQContent(faqs: Array<{ question: string; answer: string }>): string {
    return faqs.map((faq, index) => 
      `Q${index + 1}: ${faq.question}\nA${index + 1}: ${faq.answer}`
    ).join('\n\n');
  }

  /**
   * Format services content for ingestion
   */
  private formatServicesContent(services: string[]): string {
    return `
Services We Offer:

${services.map((service, index) => `${index + 1}. ${service}`).join('\n')}

Our Services:
We provide the following services: ${services.join(', ')}.

What We Do:
Our main services include ${services.join(', ')}. We are experienced in providing high-quality service in all these areas.
`.trim();
  }

  /**
   * Get knowledge base statistics
   */
  async getKnowledgeStats(tenantId: string): Promise<{
    totalChunks: number;
    totalTokens: number;
    categories: Record<string, number>;
  }> {
    const chunks = await db.getKnowledgeByTenant(tenantId);
    
    const stats = {
      totalChunks: chunks.length,
      totalTokens: chunks.reduce((sum, chunk) => sum + (chunk.tokenCount || 0), 0),
      categories: {}
    };

    // Count by category
    chunks.forEach(chunk => {
      const category = (chunk.metadata as any)?.category || 'uncategorized';
      stats.categories[category] = (stats.categories[category] || 0) + 1;
    });

    return stats;
  }
}

export const knowledgeService = new KnowledgeService();